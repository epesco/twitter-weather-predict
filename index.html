<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Twitter Weather Prediction by epesco</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Twitter Weather Prediction</h1>
        <p></p>

        <p class="view"><a href="https://github.com/epesco/twitter-weather-predict">View the Project on GitHub <small>epesco/twitter-weather-predict</small></a></p>


        <ul>
          <li><a href="https://github.com/epesco/twitter-weather-predict/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/epesco/twitter-weather-predict/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/epesco/twitter-weather-predict">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>
<a id="problem-statement" class="anchor" href="#problem-statement" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Problem Statement</h3>

<p>Five hundred million tweets are posted per day via twitter. Twitter is commonly used for sentiment analysis and     Five hundred million tweets are posted per day via twitter. Twitter is commonly used for sentiment analysis and quantifying influence, but can a tweet be used to predict the weather in a given area? Natural disasters and extreme weather prediction are popular choices for mining twitter data, but few attempts have been made for the day to day weather. This paper explores the possibility of utilizing supervised learning to classify a location’s weather after training on the lexicon associated with a certain weather type. The methods explored are a naive attempt, naive bayes, positive naive bayes, support vector machines, and ensembling. Within each algorithm, we explore the training, construction, and performance of the model. 
In 2013, CrowdFlower created a competition around solving this very task and the winner created a ridge regression model and an ensemble of forests where the output of the ensemble was fed back into the ridge regression model as input to relearn. Our aim is not for accuracy, but for analysis of more simple methods’ performance on this task. Weather prediction using tweets is complex; words are not independent of each other, given a small subset the likelihood of certain words and weather associations are skewed. The methods we use are not suited for a time series problem like weather prediction where the weather of one time step is dependent on a prior step. More complex and/or time step dependent methods should be considered as more viable options if accuracy is the ultimate goal, but we are interested in exploring the performance of simple, easily accessible algorithms in this space. </p>

<h3>
<a id="data-collection--processing" class="anchor" href="#data-collection--processing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DATA COLLECTION &amp; PROCESSING</h3>

<h4>
<a id="collection" class="anchor" href="#collection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Collection</h4>

<p>We collected data from the evening of October 4th to the morning of Oct 10th which produced 119, 061 tweets and 135 hours of weather data at half hour intervals.  Using the twitter streaming API, we filtered on location and used the OpenWeatherMap API to check weather for city of Boston. The weather data came pre-divided into 9 categories. These were Thunderstorm, Drizzle, Rain, Snow, Clear, Clouds, Extreme, Atmosphere, and Additional. Extreme weather refered to conditions like hurricanes, tornadoes, and hail. Atmosphere included conditions which impair human vision such as fog, dust, and ash. Finally, Additional was for any weather that did not fit into the above categories.
To combine our data, we iterated through the weather data and produced time ranges of each span of continuous weather and added them to a dictionary where the key was one of the weather types defined by the weather API (9 in total) and the values were tuples of time ranges that the given weather type occurred. </p>

<h4>
<a id="labeling" class="anchor" href="#labeling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Labeling</h4>

<p>We iterated through all the tweets and produced a tuple consisting of a dictionary of the features they contained and the weather label which was found by looking up the time range they fell into and labeled them according to the weather type associated with that time range. A readable example of the labeled data is below:
    ({contains(down.): True, contains(#debate): True, contains(how): True, contains(before): True, contains(the): True, contains(really): True, contains(showing): True, contains(affected): True, contains(crime): True, u'contains(<a href="https://github.com/billclinton" class="user-mention">@billclinton</a>)': True, contains(he): True, contains(there): True, contains(personally): True, contains(has): True, contains(debt): True, contains(you"): True, contains(was): True, contains(houston): True, contains("how): True,contains(cared): True, contains(that): True, contains(in): True}, 'Clear')</p>

<h4>
<a id="validation" class="anchor" href="#validation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Validation</h4>

<p>We wrote our own cross-validation function which separates the data into n folds and then trains n times. On each iteration the training is conducted on n-1 folds, and the model is then tested on the remaining fold. It tracks the accuracy and training time of the model over each fold iteration and outputs the average accuracy for all iterations.</p>

<h3>
<a id="naive-attempt" class="anchor" href="#naive-attempt" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Naive Attempt</h3>

<h4>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h4>

<p>In order to better assess the success of our machine learning algorithms, a naive solution was created to use as a baseline for success. The method which was chosen was a simple keyword comparison. Since the weather data was classified into 9 categories, as discussed in Data Collection, 6 - 10 keywords were identified for each category. For example the keywords “thunderstorm”, “lightning”, “storm", and “high wind” were all associated with the category of Thunderstorm. To evaluate the predicted conditions of each tweet the number of keywords per category from the text each was recorded. The dominant category would then be the predicted weather conditions when that tweet was sent. However, since many tweets have nothing to do with weather this approach needed to be improved slightly to have any notable success. 
To improve the accuracy of the naive approach, the tweets were bundled into 30-minute increments in order to correspond with each weather data point. To calculate the predicted weather in this 30 minute time block the total keyword count for each weather category was collected. The category with the most keywords would be selected as the prediction. If no keyword was detected in the last half hour then the previous weather was used. This is a reasonable assumption as weather rarely changes drastically over 30 min time steps. </p>

<h4>
<a id="accuracy" class="anchor" href="#accuracy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Accuracy</h4>

<p>The accuracy of the naive method was larger than we initially anticipated. The best accuracy recorded was 60.2%. Since, the prediction method was deterministic the algorithm only needed to be run once for each set of keywords on the data. We decided to compare the number of keywords per type with accuracy of the algorithm. The results of these tests can be seen in Figure 1. For all of these tests there was an average running time of 6.68 seconds. 
<img src="http://i68.tinypic.com/35lrjax.jpg" alt="Figure 1: Accuracy of the naive algorithm vs the number of keywords used"></p>

<p>The results of this experiment point out the biggest flaw with our approach. Since we collected weather data in real time for only about a week, the majority of the data was clear skys. Clear was the starting weather condition of our novice method. Therefore, even if no keywords were present it was still able to achieve 55% accuracy. The other interesting result was how 1-2 keywords resulted in much higher accuracy than larger numbers. This represents how the choice of keywords is far more important than the number used. </p>

<h3>
<a id="naive-bayes" class="anchor" href="#naive-bayes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Naive Bayes</h3>

<h4>
<a id="overview-1" class="anchor" href="#overview-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h4>

<p>Naive Bayes is a classifier which assumes independence between features. In our instance the equation can be viewed as:
P(weather|words) = P(likelihood of words) * P(weather) / P(evidence) 
Note: We don’t need P(evidence) as it is a normalizer and is present in all calculations
Naive bayes attempts to learn the P(weather|words) so that when it receives a new tweet where the words are features, it can predict the most likely weather at the time the tweet was posted.</p>

<h4>
<a id="accuracy-1" class="anchor" href="#accuracy-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Accuracy</h4>

<p>Below is the accuracy of the classifier across two to ten folds.
<img src="http://i68.tinypic.com/1425wur.jpg" alt="Figure 2: Naive Bayes accuracy vs number of folds">
Across all folds, the average accuracy of the algorithm in predicting the weather was 59.43%. Over each fold the accuracy seems to be logarithmically increasing toward ~60.5%. Notably, a separate trial of 50 folds resulted in an accuracy of 60.5%.</p>

<h4>
<a id="time" class="anchor" href="#time" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Time</h4>

<p><img src="http://i63.tinypic.com/143g66h.jpg" alt="Figure 3: Training time per cost validation">
There was a direct correlation between the number of folds and the time it took to create, train and test the model. The time increased linearly with the increase in folds at a rate of about 24 seconds per fold. The insignificant advancement in accuracy vs time it takes to construct these models alludes to the tradeoff between model accuracy/complexity and practicality.</p>

<h4>
<a id="most-informative-features" class="anchor" href="#most-informative-features" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Most Informative Features</h4>

<p>The most informative features for our final model(s) are listed below:
<img src="http://i63.tinypic.com/xn80ls.jpg" alt="Figure 4: The most informative features (words) detected by naive bayes">
It is clear that our model thinks whenever there is a presidential debate or SNL is on then it is not clear outside. These models probably wouldn’t perform super well on future data given the weather outside is independent of TV broadcasting (maybe). We were more interested in everyday nuances and colloquial conversations and word choices that could predict the weather as opposed to being overtaken by a few large-scale events. This could have been improved with more data. An interesting set of most informative features came from when we had less data (prior to the debate) which are shown below:
<img src="http://i65.tinypic.com/2ik2r05.jpg" alt="Figure 5: Particularly interesting informative features when considering current events">
The word coat indicates it is cloudy out with high certainty as well as the word pumpkins. Although I have no explanation for the latter, we aren’t concerned with why a word indicates whether just the fact that it can. However, coat makes sense in terms of what we typically associate with cloudy weather. With more data collected, we would expect to see more frequently used words independent of the major events in the twitter conversation.</p>

<h3>
<a id="positive-naive-bayes" class="anchor" href="#positive-naive-bayes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>POSITIVE NAIVE BAYES</h3>

<h4>
<a id="overview-2" class="anchor" href="#overview-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h4>

<p>Positive Naive Bayes is a variant of bayes included in the NLTK API, it trains with partially labeled data to perform a binary classification. In this implementation, models were trained for each weather type, and test inputs are then classified as either true or false as having taken place during that specific type of weather. The model requires two data sets to train, a labeled set, and an unlabeled one. The unlabeled set with a random assortment of actual weathers and is used to determine the frequency of the features from the labeled set in general vocabulary. As only three types of weather were observed there were only three models needed. After the inputs are shuffled to create the folds for cross validation, the training data is resorted into lists by known weather type to be used to train the weather models.</p>

<h4>
<a id="time-1" class="anchor" href="#time-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Time</h4>

<p>Positive Naive Bayes needs to train three models for every iteration, and classify the test set three times. There is only a slight increase in time required for training and testing more folds. The individual time for the three different models is almost identical, and the time for all of them scales to be three times slower. It also requires much lower run time than naive bayes models that include all three types of weather. 
<img src="http://i67.tinypic.com/fw7hxc.jpg" alt="Figure 6: Positive Naive Bayes training time vs number of folds"></p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p><a href="https://github.com/msmcconnell" class="user-mention">@msmcconnell</a>
<a href="https://github.com/amjaeger17" class="user-mention">@amjaeger17</a>
<a href="https://github.com/rcjacques" class="user-mention">@rcjacques</a></p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/epesco">epesco</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
